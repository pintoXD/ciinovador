#!/bin/bash

startup_timeout=300
heartbeat_timeout=300
terminate_timeout=30
check_service_file=0
service_file=`dirname /home/cinovador/Documents/course_files/practice_0/logs_cinovador/logs0/Service${COLLECTION_JOB_ID}.log`
service_file=$service_file/.DaVinciService_4701_1730288680

cd /home/cinovador/Documents/course_files/practice_0



source /home/tools/cadence/installs/IC231/share/cdssetup/adexl/job_collection_setup.sh 6



terminate_job() {
  if [ -n "$JOB_PID" ]; then
    kill -s SIGTERM $JOB_PID
    # If SIGTERM successully causes the job to exit within $terminate_timeout then
    # handle_sigchild will interrupt the sleep and the script will exit.
    sleep $terminate_timeout
    # Otherwise we will fall through to send SIGKILL.
    kill -s SIGKILL $JOB_PID
  fi
}

handle_sigchld() {
  # SIGCHLD is received for any child process exit, so we first need to verify
  # whether it's the job process that has exited.
  if [ -n "$JOB_PID" -a ! -d "/proc/$JOB_PID" ]; then
    wait $JOB_PID
    EXIT_CODE=$?
    printf "Netlist Service '$JOB_PID' stopped with exit code '$EXIT_CODE'"
    if [ $EXIT_CODE -eq 0 ]; then  
      test -f /home/cinovador/Documents/course_files/practice_0/logs_cinovador/logs0/Service${COLLECTION_JOB_ID}.log.err && rm -f /home/cinovador/Documents/course_files/practice_0/logs_cinovador/logs0/Service${COLLECTION_JOB_ID}.log.err 
    fi
    unset JOB_PID
    exit $EXIT_CODE
  fi
}

handle_sigterm() {
  # If the script receives a signal to terminate, then pass this on to the job process
  terminate_job
}

handle_exit() {
  # Ensure that the job process and heartbeat file are cleaned up up on exit
  # (but note that this handler will not be called if the script receives SIGKILL)
  # Here we directly send SIGKILL to the job process because it should already have
  # been terminated more cleanly via terminate_job. So something's gone wrong, and
  # we don't want to hang around in the exit handler by trying a cleaner termination.
  [ -n "$JOB_PID" ] && kill -s SIGKILL "$JOB_PID" >& /dev/null && wait $JOB_PID
  [ -n "$heartbeat" ] && /bin/rm -f "$heartbeat"
}

## Must enable job control in order to trap SIGCHLD
set -o monitor
trap "handle_sigchld" SIGCHLD
trap "handle_sigterm" SIGHUP SIGTERM
trap "handle_exit" EXIT

# Create heartbeat file. I considered using the job's process ID to make the filename
# unique but process IDs are eventually recycled by the kernel, so there is a small risk
# the file might already exist (because it was not cleaned up properly) and be owned by
# a different user so we may not have permission to overwrite it. Hence the use of mktemp
# which guarantees atomic creation of a file with a unique name. The heartbeat filename
# must be passed into the job process, so it knows which file to touch.
heartbeat=`mktemp /dev/shm/swift-heartbeat.XXXXXXXXXX`
last_heartbeat=`stat -c %y "$heartbeat"`

virtuoso -beanhost "cinova05.lesc.ufc.br" -beanport 11376 -beanbinlog "" -beanLogFile "/home/cinovador/Documents/course_files/practice_0/logs_cinovador/logs0/amps_Service${COLLECTION_JOB_ID}.log"  -mpssession "virtuoso4701" -mpshost "cinova05.lesc.ufc.br" -davinciService DaVinciService_4701_1730288680 -scopedPid 4701 -axlSession fnxSession2 -axlServiceIdFlag $COLLECTION_JOB_ID -uuid "${COLLECTION_JOB_UUID}" -heartbeat "$heartbeat" -log /home/cinovador/Documents/course_files/practice_0/logs_cinovador/logs0/Service${COLLECTION_JOB_ID}.log   -adeBrokerAddress "cinova05.lesc.ufc.br:41511"  -noautostart -nograph -lscs 000175E1894CBE06FF0966E38F1FFC06BC4D7EED88199869CA2C7EEDDC43CC33CA2C39A0A173FC06867D66E38F1FFC06BC4D66E38F1FFC06BC4D01C191CBE2D2DB6F00001E90 -interactive -offlineExprEval -upfrontMode -fenixMode explorer -heartbeatTimeout "" -lingerTimeout 300 -pointlifetime -1   <<< '_axlRunServices()'  1>/dev/null  2>/home/cinovador/Documents/course_files/practice_0/logs_cinovador/logs0/Service${COLLECTION_JOB_ID}.log.err  &

JOB_PID=$!
HOST_NAME=$(hostname)

printf "Netlist Service '$JOB_PID' is starting up on host '$HOST_NAME'"
status="starting"

# Use a separate startup timeout because it can take a significant amount of time to
# start up the job process, and it allows use of a finer timeout granularity to
# detect unresponsives once it is running.

start=0
while [ $start -lt $startup_timeout ]; do
  if [[ `stat -c %y $heartbeat` > $last_heartbeat ]]; then
    start=$[$startup_timeout+1]
  else
    start=$[$start+1]
    sleep 1
  fi
done

# Loop while process is running. Strictly speaking this test should not be necessary
# because the script receives SIGCHLD when the process stops and will then exit
# itself. But it's left in for robustness.
while [ -d "/proc/$JOB_PID" ]; do

  ## [[ ]] is a bash extension. It's used so that we can compare the timestamp
  ## strings with '>' (string lexicographical sort order). And note that it
  ## does not require vars to be in quotes to handle empty values and spaces.
  if [[ ! `stat -c %y $heartbeat` > $last_heartbeat && ($check_service_file == 0 || ($check_service_file != 0 && ! -e $service_file)) ]]; then
    if [[ $status == "starting" ]]; then
      cdsmps -c 'mpsSend(mpsMakePattern("ADE-service-status-DaVinciService_4701_1730288680-fnxSession2" "{\"jobId\":6,\"status\":\"starttimeout\"}"))'
    fi
    # No new heartbeat since last check implies an unresponsive process
    # Non-empty file means that the heartbeat check is temporarily disabled
    if [[ -z $heartbeat ]] ; then
        terminate_job
    fi
  else
    last_heartbeat=`stat -c %y "$heartbeat"`
  fi
  status="started"

  heartbeat_sec=0
  while [ $heartbeat_sec -lt $heartbeat_timeout -a -d "/proc/$JOB_PID" ]; do
    heartbeat_sec=$[$heartbeat_sec + 1]
    sleep 1
  done

done
